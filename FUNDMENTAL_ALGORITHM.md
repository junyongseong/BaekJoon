# ê¸°ì´ˆì ì¸ ì‹¤ì „ ë¬¸ì¬ë¥¼ ì ìš©í•  ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•˜ëŠ” ê³µê°„ì…ë‹ˆë‹¤.
## ë°°ì—´, ë¬¸ìì—´, ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ê°™ì€ê²ƒì´ ê·¸ ì˜ˆì‹œí™ë‹ˆë‹¤.

### ë¬¸ìì—´ ì •ë ¬(1181ë²ˆ)

í•µì‹¬ ì•Œê³ ë¦¬ì¦˜: Comparatorë¥¼ ì´ìš©í•œ ì´ì¤‘ ì •ë ¬ (ê¸¸ì´ â†’ ì‚¬ì „ìˆœ)

ë¬¸ìì—´ ë°°ì—´ ì •ë ¬ ê¸°ì¤€ ì§ì ‘ ì •ì˜

compareTo()ì™€ length()ë¥¼ í•¨ê»˜ ì‚¬ìš©í•œ ì»¤ìŠ¤í…€ ì •ë ¬

ì¤‘ë³µ ì œê±° ì‹œ equals()ì™€ ì¸ë±ìŠ¤ ì£¼ì˜
```
for (int i = 0; i < N; i++) arr[i] = br.readLine();

        Arrays.sort(arr, (a, b) -> {
            if (a.length() == b.length()) return a.compareTo(b);
            return a.length() - b.length();
        });

        StringBuilder sb = new StringBuilder();
        sb.append(arr[0]).append('\n');
        for (int i = 1; i < N; i++) {
            if (!arr[i].equals(arr[i - 1])) sb.append(arr[i]).append('\n');
        }
        System.out.println(sb);
```

### í•µì‹¬ ì•Œê³ ë¦¬ì¦˜: í´ë¦¬ë…¸ë¯¸ì–¼ ë¡¤ë§ í•´ì‹œ(Polynomial Rolling Hash)
í•™ìŠµ í¬ì¸íŠ¸: Math.pow() ëŒ€ì‹  r *= 31ë¡œ ì§€ìˆ˜ ì²˜ë¦¬

ì˜¤ë²„í”Œë¡œìš° ë°©ì§€ë¥¼ ìœ„í•œ mod ì—°ì‚° (1234567891ì€ í° ì†Œìˆ˜)
(result + val * r) % MOD êµ¬ì¡° ì´í•´

        final int MOD = 1234567891;
        long result = 0;
        long r = 1; // 31^0

        for (int i = 0; i < L; i++) {
            int val = str.charAt(i) - 'a' + 1;
            result = (result + val * r) % MOD;
            r = (r * 31) % MOD;
        }
        System.out.println(result);
        
### ğŸ§® ì´í•­ê³„ìˆ˜ (Binomial Coefficient, ë°±ì¤€ 11050)
---
#### ğŸ§  í•µì‹¬ ì•Œê³ ë¦¬ì¦˜
> ì´í•­ê³„ìˆ˜ëŠ” â€œì¡°í•©(Combination)â€ì„ ê³„ì‚°í•˜ëŠ” ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜.  
> ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥:
> 1ï¸âƒ£ **ì¬ê·€ì‹ (Pascalâ€™s Triangle ê³µì‹)**  
> 2ï¸âƒ£ **DP í…Œì´ë¸” (Bottom-Up ë™ì  í”„ë¡œê·¸ë˜ë°)**

---

#### âš™ï¸ 1ï¸âƒ£ ì¬ê·€ì‹ ë°©ì‹ (Recursive Version)

```
// íŒŒìŠ¤ì¹¼ì˜ ì¬ê·€ì‹: C(n, k) = C(n-1, k-1) + C(n-1, k)
static int combinationRecursive(int n, int k) {
    if (n == k || k == 0)
        return 1;
    return combinationRecursive(n - 1, k - 1) + combinationRecursive(n - 1, k);
}
```
ğŸ“¥ ì…ë ¥ ì˜ˆì‹œ


System.out.println(combinationRecursive(5, 2)); // 10


ğŸ§  íŠ¹ì§•
ê¸°ì € ì¡°ê±´	n==k ë˜ëŠ” k==0 â†’ 1
ì í™”ì‹	C(n,k) = C(n-1,k-1) + C(n-1,k)
ì‹œê°„ë³µì¡ë„	O(2â¿) (ì¤‘ë³µ í˜¸ì¶œ å¤š)
ì¥ì 	êµ¬ì¡°ê°€ ìˆ˜í•™ ê³µì‹ ê·¸ëŒ€ë¡œë¼ ì§ê´€ì 
ë‹¨ì 	ì…ë ¥ ì»¤ì§ˆìˆ˜ë¡ ì†ë„ ëŠë¦¼

âš™ï¸ 2ï¸âƒ£ DP í…Œì´ë¸” ë°©ì‹ (Dynamic Programming Version)
```
// ë°”í…€ì—… DP ë°©ì‹
static int combinationDP(int N, int K) {
    int[][] dp = new int[N + 1][K + 1];

    for (int n = 0; n <= N; n++) {
        for (int k = 0; k <= Math.min(n, K); k++) {
            if (k == 0 || k == n)
                dp[n][k] = 1; // ê°€ì¥ìë¦¬ ê°’ì€ í•­ìƒ 1
            else
                dp[n][k] = dp[n - 1][k - 1] + dp[n - 1][k];
        }
    }
    return dp[N][K];
}
```
ğŸ“¥ ì…ë ¥ ì˜ˆì‹œ
System.out.println(combinationDP(5, 2)); // 10

ğŸ§  íŠ¹ì§•

í¬ì¸íŠ¸	ì„¤ëª…
ì í™”ì‹	dp[n][k] = dp[n-1][k-1] + dp[n-1][k]
ê¸°ì € ì¡°ê±´	dp[n][0] = dp[n][n] = 1
ì‹œê°„ë³µì¡ë„	O(NÃ—K)
ì¥ì 	ë¹ ë¥´ê³  ì•ˆì •ì 
ë‹¨ì 	ë©”ëª¨ë¦¬ ì‚¬ìš© O(NÃ—K)
       



#### DP í”¼ë³´ë‚˜ì¹˜ (1003ë²ˆ)

í•µì‹¬ ì•Œê³ ë¦¬ì¦˜: ì¬ê·€ + ë©”ëª¨ì´ì œì´ì…˜(Memoization)
í•µì‹¬ í¬ì¸íŠ¸: Integerë¡œ null ì²´í¬í•˜ì—¬ ë¯¸ê³„ì‚° ìƒíƒœ êµ¬ë¶„
intëŠ” ê¸°ë³¸ê°’ 0ì´ë¼ â€œê³„ì‚° ì•ˆ ë¨â€ ìƒíƒœë¥¼ êµ¬ë¶„ ë¶ˆê°€
IntegerëŠ” null ê°€ëŠ¥ â†’ if (dp[n] == null)ë¡œ ì²´í¬
DPë¥¼ ì´ìš©í•´ ì¤‘ë³µ í˜¸ì¶œì„ ë§‰ê³  ì¬ê·€ ì •ì˜ ê·¸ëŒ€ë¡œ êµ¬í˜„
```
static Integer[][] dp = new Integer[40][2];

static Integer[] fibo(int n) {
    if (dp[n][0] == null || dp[n][1] == null) {
        dp[n][0] = fibo(n - 1)[0] + fibo(n - 2)[0];
        dp[n][1] = fibo(n - 1)[1] + fibo(n - 2)[1];
    }
    return dp[n];
}
```

ğŸ’¡ intë¥¼ ì“¸ ê²½ìš°ì—” -1ë¡œ ì´ˆê¸°í™”í•´ â€œë¯¸ê³„ì‚°â€ í‘œì‹œ ëŒ€ì²´ ê°€ëŠ¥
ë‹¨, ìŒìˆ˜ ê°’ì´ ê²°ê³¼ë¡œ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤ë©´ í˜¼ë™ ì£¼ì˜.
| êµ¬ë¶„ | Integer | int + -1 |
|------|----------|-----------|
| ë¯¸ê³„ì‚° ì²´í¬ | âœ… null | âšª -1 |
| ê°€ë…ì„± | âœ… ì¢‹ìŒ | âšª ë³´í†µ |
| ë©”ëª¨ë¦¬ | âšª í¼ | âœ… ì‘ìŒ |

ğŸŒ€ ì™œ ì¬ê·€ë¥¼ ì¼ëŠ”ê°€?

í”¼ë³´ë‚˜ì¹˜ëŠ” ë³¸ì§ˆì ìœ¼ë¡œ f(n) = f(n-1) + f(n-2) í˜•íƒœì˜ ì¬ê·€ì  ìˆ˜í•™ ì •ì˜ì‹
ë°˜ë³µë¬¸ë³´ë‹¤ ì •ì˜ë¥¼ ê·¸ëŒ€ë¡œ ì½”ë“œë¡œ ì˜®ê¸°ê¸° ì‰¬ì›€
DPì™€ ê²°í•© ì‹œ â€œì¤‘ë³µ í˜¸ì¶œ ì œê±° + êµ¬ì¡°ì  ì§ê´€ì„±â€ ë‘˜ ë‹¤ í™•ë³´ ê°€ëŠ¥


#### DP í”¼ë³´ë‚˜ì¹˜ (1003ë²ˆ)

í•µì‹¬ ì•Œê³ ë¦¬ì¦˜: ì¬ê·€ + ë©”ëª¨ì´ì œì´ì…˜(Memoization)
í•µì‹¬ í¬ì¸íŠ¸: Integerë¡œ null ì²´í¬í•˜ì—¬ ë¯¸ê³„ì‚° ìƒíƒœ êµ¬ë¶„
intëŠ” ê¸°ë³¸ê°’ 0ì´ë¼ â€œê³„ì‚° ì•ˆ ë¨â€ ìƒíƒœë¥¼ êµ¬ë¶„ ë¶ˆê°€
IntegerëŠ” null ê°€ëŠ¥ â†’ if (dp[n] == null)ë¡œ ì²´í¬
DPë¥¼ ì´ìš©í•´ ì¤‘ë³µ í˜¸ì¶œì„ ë§‰ê³  ì¬ê·€ ì •ì˜ ê·¸ëŒ€ë¡œ êµ¬í˜„
```
static Integer[][] dp = new Integer[40][2];

static Integer[] fibo(int n) {
    if (dp[n][0] == null || dp[n][1] == null) {
        dp[n][0] = fibo(n - 1)[0] + fibo(n - 2)[0];
        dp[n][1] = fibo(n - 1)[1] + fibo(n - 2)[1];
    }
    return dp[n];
}
```

ğŸ’¡ intë¥¼ ì“¸ ê²½ìš°ì—” -1ë¡œ ì´ˆê¸°í™”í•´ â€œë¯¸ê³„ì‚°â€ í‘œì‹œ ëŒ€ì²´ ê°€ëŠ¥
ë‹¨, ìŒìˆ˜ ê°’ì´ ê²°ê³¼ë¡œ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤ë©´ í˜¼ë™ ì£¼ì˜.
| êµ¬ë¶„ | Integer | int + -1 |
|------|----------|-----------|
| ë¯¸ê³„ì‚° ì²´í¬ | âœ… null | âšª -1 |
| ê°€ë…ì„± | âœ… ì¢‹ìŒ | âšª ë³´í†µ |
| ë©”ëª¨ë¦¬ | âšª í¼ | âœ… ì‘ìŒ |

ğŸŒ€ ì™œ ì¬ê·€ë¥¼ ì¼ëŠ”ê°€?

í”¼ë³´ë‚˜ì¹˜ëŠ” ë³¸ì§ˆì ìœ¼ë¡œ f(n) = f(n-1) + f(n-2) í˜•íƒœì˜ ì¬ê·€ì  ìˆ˜í•™ ì •ì˜ì‹
ë°˜ë³µë¬¸ë³´ë‹¤ ì •ì˜ë¥¼ ê·¸ëŒ€ë¡œ ì½”ë“œë¡œ ì˜®ê¸°ê¸° ì‰¬ì›€
DPì™€ ê²°í•© ì‹œ â€œì¤‘ë³µ í˜¸ì¶œ ì œê±° + êµ¬ì¡°ì  ì§ê´€ì„±â€ ë‘˜ ë‹¤ í™•ë³´ ê°€ëŠ¥